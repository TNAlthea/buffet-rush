function random_customer(self, node)
	local RENDANG = hash("rendang")
	local STEAK = hash("steak")
	local IKANTELURASIN = hash("ikantelurasin")
	local CAPCAY = hash("capcay")
	
	local rand = math.random(1, 4)

	if rand == 1 then
		customer_queue(self, RENDANG, node)
	elseif rand == 2 then
		customer_queue(self, STEAK, node)
	elseif rand == 3 then
		customer_queue(self, IKANTELURASIN, node)
	elseif rand == 4 then
		customer_queue(self, CAPCAY, node)
	end
	
end

function customer_queue(self, customer_id, node)
	local RENDANG = hash("rendang")
	local STEAK = hash("steak")
	local IKANTELURASIN = hash("ikantelurasin")
	local CAPCAY = hash("capcay")
	
	local listCustomer = {
		[RENDANG] = {
			name = "rendang",
			hash = RENDANG,
			cheeseReq = 0,
			eggReq = 0,
			sausageReq = 0,
			fishReq = 0,
			meatReq = 12,
			riceReq = 7,
			patience = 8,
			bonusPoints = 10,
			penalty = 5,
		},
		[STEAK] = {
			name = "steak",
			hash = STEAK,
			cheeseReq = 2,
			eggReq = 0,
			sausageReq = 3,
			fishReq = 0,
			meatReq = 6,
			riceReq = 3,
			patience = 12,
			bonusPoints = 14,
			penalty = 7,
		},
		[IKANTELURASIN] = {
			name = "ikan telur asin",
			hash = IKANTELURASIN,
			cheeseReq = 0,
			eggReq = 2,
			sausageReq = 3,
			fishReq = 6,
			meatReq = 0,
			riceReq = 4,
			patience = 7,
			bonusPoints = 7,
			penalty = 3,
		},
		[CAPCAY] = {
			name = "capcay",
			hash = CAPCAY,
			cheeseReq = 0,
			eggReq = 3,
			sausageReq = 3,
			fishReq = 4,
			meatReq = 4,
			riceReq = 4,
			patience = 9,
			bonusPoints = 11,
			penalty = 5,
		},
	}
	
	local customer = listCustomer[customer_id]
	
	if self.customerQueue.currentCustomerCount + 1 > self.customerQueue.maxCustomer then
		return false, "Customer queue is full!"
	end	
	
	table.insert(self.customerQueue.customer, {customer = customer, node = node})
	self.customerQueue.currentCustomerCount = self.customerQueue.currentCustomerCount + 1
	
	return true
end 

function active_customer(self, customer_id, node)
	local RENDANG = hash("rendang")
	local STEAK = hash("steak")
	local IKANTELURASIN = hash("ikantelurasin")
	local CAPCAY = hash("capcay")
	
	local listCustomer = {
		[RENDANG] = {
			name = "rendang",
			hash = RENDANG,
			cheeseReq = 0,
			eggReq = 0,
			sausageReq = 0,
			fishReq = 0,
			meatReq = 12,
			riceReq = 7,
			patience = 8,
			bonusPoints = 10,
			penalty = 5,
		},
		[STEAK] = {
			name = "steak",
			hash = STEAK,
			cheeseReq = 2,
			eggReq = 0,
			sausageReq = 3,
			fishReq = 0,
			meatReq = 6,
			riceReq = 3,
			patience = 12,
			bonusPoints = 14,
			penalty = 7,
		},
		[IKANTELURASIN] = {
			name = "ikan telur asin",
			hash = IKANTELURASIN,
			cheeseReq = 0,
			eggReq = 2,
			sausageReq = 3,
			fishReq = 6,
			meatReq = 0,
			riceReq = 4,
			patience = 7,
			bonusPoints = 7,
			penalty = 3,
		},
		[CAPCAY] = {
			name = "capcay",
			hash = CAPCAY,
			cheeseReq = 0,
			eggReq = 3,
			sausageReq = 3,
			fishReq = 4,
			meatReq = 4,
			riceReq = 4,
			patience = 9,
			bonusPoints = 11,
			penalty = 5,
		},
	}
	
	local customer = listCustomer[customer_id]
	
	if self.activeCustomer.activeCount + 1 > self.activeCustomer.maxActive then
		return false, "Active queue is full!"
	end

	self.activeCustomer.activeCount = self.activeCustomer.activeCount + 1
	table.insert(self.activeCustomer.customer, customer)
	-- reduce queue count
	self.customerQueueCount = self.customerQueueCount - 1
	
	local gui_root = gui.get_node("activeCustomer")
	-- clone template node
	local cloned_gui=gui.clone_tree(gui_root)
	local pos = gui.get_position(gui_root)
	local newPos = pos + vmath.vector3(0, -170 * self.activeCustomer.activeCount, 0)

	-- give unique node ID into cloned template nodes
	gui.set_id(cloned_gui[hash("activeCustomer")], "activeCustomer" .. self.activeCustomer.activeCount)

	-- attach customer menu order into the node and show on the GUI
	gui.set_alpha(cloned_gui[hash("activeCustomer")], 1)
	gui.animate(cloned_gui[hash("activeCustomer")], gui.PROP_POSITION, newPos, gui.EASING_INOUTSINE, 0.7)

	gui.set_text((cloned_gui[hash("namaMenuActive")]), self.activeCustomer.customer[self.activeCustomer.activeCount].name)
	gui.set_id((cloned_gui[hash("namaMenuActive")]), "namaMenuActive" .. self.activeCustomer.activeCount)

	gui.set_text((cloned_gui[hash("cheeseActiveCounter")]), self.activeCustomer.customer[self.activeCustomer.activeCount].cheeseReq)
	gui.set_id((cloned_gui[hash("cheeseActiveCounter")]), "cheeseActiveCounter" .. self.activeCustomer.activeCount)

	gui.set_text((cloned_gui[hash("eggActiveCounter")]), self.activeCustomer.customer[self.activeCustomer.activeCount].eggReq)
	gui.set_id((cloned_gui[hash("eggActiveCounter")]), "eggActiveCounter" .. self.activeCustomer.activeCount)

	gui.set_text((cloned_gui[hash("fishActiveCounter")]), self.activeCustomer.customer[self.activeCustomer.activeCount].fishReq)
	gui.set_id((cloned_gui[hash("fishActiveCounter")]), "fishActiveCounter" .. self.activeCustomer.activeCount)

	gui.set_text((cloned_gui[hash("meatActiveCounter")]), self.activeCustomer.customer[self.activeCustomer.activeCount].meatReq)
	gui.set_id((cloned_gui[hash("meatActiveCounter")]), "meatActiveCounter" .. self.activeCustomer.activeCount)

	gui.set_text((cloned_gui[hash("riceActiveCounter")]), self.activeCustomer.customer[self.activeCustomer.activeCount].riceReq)
	gui.set_id((cloned_gui[hash("riceActiveCounter")]), "riceActiveCounter" .. self.activeCustomer.activeCount)

	gui.set_text((cloned_gui[hash("sausageActiveCounter")]), self.activeCustomer.customer[self.activeCustomer.activeCount].sausageReq)
	gui.set_id((cloned_gui[hash("sausageActiveCounter")]), "sausageActiveCounter" .. self.activeCustomer.activeCount)

	gui.set_text((cloned_gui[hash("patienceActiveCounter")]), self.activeCustomer.customer[self.activeCustomer.activeCount].patience)
	gui.set_id((cloned_gui[hash("patienceActiveCounter")]), "patienceActiveCounter" .. self.activeCustomer.activeCount)
	return true 
end

function move_queue(self, index)
	local RENDANG = hash("rendang")
	local STEAK = hash("steak")
	local IKANTELURASIN = hash("ikantelurasin")
	local CAPCAY = hash("capcay")
	
	local listCustomer = {
		[RENDANG] = {
			name = "rendang",
			hash = RENDANG,
			cheeseReq = 0,
			eggReq = 0,
			sausageReq = 0,
			fishReq = 0,
			meatReq = 12,
			riceReq = 7,
			patience = 8,
			bonusPoints = 10,
			penalty = 5,
		},
		[STEAK] = {
			name = "steak",
			hash = STEAK,
			cheeseReq = 2,
			eggReq = 0,
			sausageReq = 3,
			fishReq = 0,
			meatReq = 6,
			riceReq = 3,
			patience = 12,
			bonusPoints = 14,
			penalty = 7,
		},
		[IKANTELURASIN] = {
			name = "ikan telur asin",
			hash = IKANTELURASIN,
			cheeseReq = 0,
			eggReq = 2,
			sausageReq = 3,
			fishReq = 6,
			meatReq = 0,
			riceReq = 4,
			patience = 7,
			bonusPoints = 7,
			penalty = 3,
		},
		[CAPCAY] = {
			name = "capcay",
			hash = CAPCAY,
			cheeseReq = 0,
			eggReq = 3,
			sausageReq = 3,
			fishReq = 4,
			meatReq = 4,
			riceReq = 4,
			patience = 9,
			bonusPoints = 11,
			penalty = 5,
		},
	}
	
	nextIndex = index + 1
	tableIndex = 0
	for _, data in ipairs(self.customerQueue.customer) do
		tableIndex = tableIndex + 1
	end
	
	table.remove(self.customerQueue.customer, index)
	
	local i = index

	if tableIndex == 1 then
		gui.delete_node(gui.get_node("listQueue" .. tableIndex))
	-- delete the queue node then move the other queue
	elseif tableIndex > 1 then
		local gui_root = gui.get_node("listQueue")
		-- delete all queue gui nodes first
		for i = index, tableIndex do
			gui.delete_node(gui.get_node("listQueue" .. i))
		end

		-- redraw rest of queue with their new IDs
		for i = 1, tableIndex-1 do
			local cloned_gui=gui.clone_tree(gui_root)
			local pos = gui.get_position(gui_root)
			local newPos = pos + vmath.vector3(295 * i, 0, 0)
			
			self.customerQueue.customer[i].node = hash("listQueue" .. i)
			
			-- reassign gui node id 
			gui.set_id(cloned_gui[hash("listQueue")], "listQueue" .. i)

			-- attach customer menu order into the node and show on the GUI
			gui.set_alpha(cloned_gui[hash("listQueue")], 1)
			gui.animate(cloned_gui[hash("listQueue")], gui.PROP_POSITION, newPos, gui.EASING_INOUTSINE, 0.7)

			gui.set_text((cloned_gui[hash("namaMenu")]), self.customerQueue.customer[i].customer.name)
			gui.set_id((cloned_gui[hash("namaMenu")]), "namaMenu" .. i)

			gui.set_text((cloned_gui[hash("cheeseCounter")]), self.customerQueue.customer[i].customer.cheeseReq)
			gui.set_id((cloned_gui[hash("cheeseCounter")]), "cheeseCounter" .. i)

			gui.set_text((cloned_gui[hash("eggCounter")]), self.customerQueue.customer[i].customer.eggReq)
			gui.set_id((cloned_gui[hash("eggCounter")]), "eggCounter" .. i)

			gui.set_text((cloned_gui[hash("meatCounter")]), self.customerQueue.customer[i].customer.meatReq)
			gui.set_id((cloned_gui[hash("meatCounter")]), "meatCounter" .. i)

			gui.set_text((cloned_gui[hash("riceCounter")]), self.customerQueue.customer[i].customer.riceReq)
			gui.set_id((cloned_gui[hash("riceCounter")]), "riceCounter" .. i)

			gui.set_text((cloned_gui[hash("sausageCounter")]), self.customerQueue.customer[i].customer.sausageReq)
			gui.set_id((cloned_gui[hash("sausageCounter")]), "sausageCounter" .. i)

			gui.set_text((cloned_gui[hash("patienceCounter")]), self.customerQueue.customer[i].customer.patience)
			gui.set_id((cloned_gui[hash("patienceCounter")]), "patienceCounter" .. i)
		end
	end
	
end

function init(self)
	-- Add initialization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
	msg.post("#", "show_game")
	msg.post(".", "acquire_input_focus")

	self.active = false
	
	self.turns = 30
	self.points = 0
	self.combos = 0
	self.prevMessage = nil
	self.customerQueueCount = 0
	self.newCustomerTurns = 1
	self.queue = {}

	self.customerQueue = {
		currentCustomerCount = 0,
		maxCustomer = 5,
		customer = {},
	}

	self.activeCustomer = {
		activeCount = 0,
		maxActive = 3,
		customer = {},
	}

end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function update(self, dt)
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function on_message(self, message_id, message, sender)
	local turns_node = gui.get_node("turnsTickerCounter")
	local points_node = gui.get_node("pointsCounter")

	if message_id == hash("show_game") then
		msg.post("#", "enable")
		self.active = true
	end
	
	if message_id == hash("reduce_turns") then
		self.turns = self.turns - 1
		gui.set_text(turns_node, self.turns)
		self.prevMessage = message_id
		
		local gui_root = gui.get_node("listQueue")
		
		for _,data in ipairs(self.activeCustomer.customer) do 
			self.activeCustomer.customer[_].patience = self.activeCustomer.customer[_].patience - 1
			if self.activeCustomer.customer[_].patience < 3 then
				gui.set_color(gui.get_node("patienceActiveCounter" .. _), vmath.vector3(1, 0, 0))
			end
			if self.activeCustomer.customer[_].patience == 0 then
				msg.post("#", "update_points", {points = -self.activeCustomer.customer[_].penalty})
			end
			gui.set_text(gui.get_node("patienceActiveCounter" .. _), self.activeCustomer.customer[_].patience)
		end
		
		-- New customer comes in every 2 turns if not full (max 3 customer in Queue)
		if self.customerQueueCount < 3 and self.newCustomerTurns == 0 then
			self.customerQueueCount = self.customerQueueCount + 1
			self.newCustomerTurns = 2

			-- clone template node
			local cloned_gui=gui.clone_tree(gui_root)
			local pos = gui.get_position(gui_root)
			local newPos = pos + vmath.vector3(295 * self.customerQueueCount, 0, 0)

			-- give unique node ID into cloned template nodes
			gui.set_id(cloned_gui[hash("listQueue")], "listQueue" .. self.customerQueueCount)
			
			-- attach customer menu order into the node and show on the GUI
			gui.set_alpha(cloned_gui[hash("listQueue")], 1)
			gui.animate(cloned_gui[hash("listQueue")], gui.PROP_POSITION, newPos, gui.EASING_INOUTSINE, 0.7)

			random_customer(self, gui.get_id(cloned_gui[hash("listQueue")]))

			gui.set_text((cloned_gui[hash("namaMenu")]), self.customerQueue.customer[self.customerQueueCount].customer.name)
			gui.set_id((cloned_gui[hash("namaMenu")]), "namaMenu" .. self.customerQueueCount)
			
			gui.set_text((cloned_gui[hash("cheeseCounter")]), self.customerQueue.customer[self.customerQueueCount].customer.cheeseReq)
			gui.set_id((cloned_gui[hash("cheeseCounter")]), "cheeseCounter" .. self.customerQueueCount)
			
			gui.set_text((cloned_gui[hash("eggCounter")]), self.customerQueue.customer[self.customerQueueCount].customer.eggReq)
			gui.set_id((cloned_gui[hash("eggCounter")]), "eggCounter" .. self.customerQueueCount)
			
			gui.set_text((cloned_gui[hash("meatCounter")]), self.customerQueue.customer[self.customerQueueCount].customer.meatReq)
			gui.set_id((cloned_gui[hash("meatCounter")]), "meatCounter" .. self.customerQueueCount)

			gui.set_text((cloned_gui[hash("riceCounter")]), self.customerQueue.customer[self.customerQueueCount].customer.riceReq)
			gui.set_id((cloned_gui[hash("riceCounter")]), "riceCounter" .. self.customerQueueCount)
			
			gui.set_text((cloned_gui[hash("sausageCounter")]), self.customerQueue.customer[self.customerQueueCount].customer.sausageReq)
			gui.set_id((cloned_gui[hash("sausageCounter")]), "sausageCounter" .. self.customerQueueCount)
			
			gui.set_text((cloned_gui[hash("patienceCounter")]), self.customerQueue.customer[self.customerQueueCount].customer.patience)
			gui.set_id((cloned_gui[hash("patienceCounter")]), "patienceCounter" .. self.customerQueueCount)
		end
		if self.newCustomerTurns > 0 then
			self.newCustomerTurns = self.newCustomerTurns - 1
		end
		
	end
	if message_id == hash("combos") and self.prevMessage == hash("reduce_turns") then
		self.prevMessage = message_id
	end 
	if message_id == hash("update_points") and self.prevMessage == hash("reduce_turns") then
		self.points = self.points + message.points
		gui.set_text(points_node, self.points)
		sound.play("sounds#onMatch", {delay = 0, gain = 1, pan = -1.0, speed = 0.85})
		self.prevMessage = hash("reduce_turns") -- in case of continous match so this function can be called repeatedly until the combo ends 

		-- if score are positive
		if message.points > 0 then
			gui.set_alpha(gui.get_node("pointsChange"), 1)
			gui.set_text(gui.get_node("pointsChange"), "+" .. message.points)
			gui.set_color(gui.get_node("pointsChange"), vmath.vector3(0, 1, 0)) -- green color
		else 
			gui.set_alpha(gui.get_node("pointsChange"), 1)
			gui.set_text(gui.get_node("pointsChange"), message.points)
			gui.set_color(gui.get_node("pointsChange"), vmath.vector3(1, 0, 0)) -- red color
		end
		-- set alpha back to 0 (invisible)
		timer.delay(2, false, function() gui.set_alpha(gui.get_node("pointsChange"), 0) end)
	end
end



function on_input(self, action_id, action)
	-- Add input-handling code here. The game object this script is attached to
	-- must have acquired input focus:
	--
	--    msg.post(".", "acquire_input_focus")
	--
	-- All mapped input bindings will be received. Mouse and touch input will
	-- be received regardless of where on the screen it happened.
	-- Learn more: https://defold.com/manuals/input/
	-- Remove this function if not needed

	if action_id == hash("touch") and action.pressed and self.active then
		if gui.pick_node(gui.get_node("pause"), action.x, action.y) then
			print("pause klik")
			local i = 0
			for _,data in ipairs(self.customerQueue.customer) do
				-- print(self.customerQueue.customer[_].node)
			end
			pprint(self.customerQueue.customer)
		end
		for _,customer in ipairs(self.customerQueue.customer) do
			if gui.pick_node(gui.get_node("listQueue" .. _), action.x, action.y) then
				active_customer(self, self.customerQueue.customer[_].customer.hash, a)
				move_queue(self, _)
			end
		end
	end
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end
